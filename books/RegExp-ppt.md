<h1 align="center">
    RegExp
</h1>

## 正则表达式是一门编程语言

![img](https://static001.geekbang.org/resource/image/3b/32/3b179079422edda52b1034f101f85b32.jpg)

* 更专注于某个特定、专门的业务逻辑和问题领域
* 主要负责分析问题，以及使用第 4 代语言来描述问题, 无需花费大量时间。去考虑具体的处理逻辑和算法实现

* 声明式编程范式

  * 重目标、轻过程，专注问题的分析和表达，而不是算法实现

* 基本语法结构

  * 顺序结构（也称为连接结构）、分支结构（也称为选择结构）、循环结构（也称为重复结构）

    ```
    (张三|李四*)*
    ```



## 流派之分

### POSIX 流派

* BRE 标准（Basic Regular Expression 基本正则表达式）

* ERE 标准（Extended Regular Expression 扩展正则表达式）

<img src="https://static001.geekbang.org/resource/image/53/6f/53fe0982c70fe89dff733345a6816e6f.png" width="800"/>

### PCRE 流派

**目前大部分常用编程语言都是源于 PCRE 标准，这个流派显著特征是有\d、\w、\s 这类字符组简记方式**

### 不同环境使用正则

* 在类Unix中使用正则
  * grep、sed、vi/vim 等属于 BRE 标准
  * egrep、awk 属于 ERE 标准
  * 使用 man grep 等查看



## 原理

### 有穷状态自动机

- 一个系统具有有穷个状态，不同的状态代表不同的意义
- 自动机是指系统可以根据相应的条件，在不同的状态下进行转移
- 从一个初始状态，根据对应的操作（比如录入的字符集）执行状态转移，最终达到终止状态（可能有一到多个终止状态）

有穷自动机的具体实现称为正则引擎，主要有 DFA 和 NFA 两种，其中 NFA 又分为传统的 NFA 和 POSIX NFA

- DFA：确定性有穷自动机（Deterministic finite automaton）
- NFA：非确定性有穷自动机（Non-deterministic finite automaton） 

```
for example
字符串: abbbba
正则: a(bb)+a
```

[图形化展示](https://regexper.com/)

* NFA 和 DFA 是可以相互转化的

### DFA& NFA 工作机制

- NFA 引擎的工作方式是，先看正则，再看文本，而且以正则为主导

  ```
  正则：reg(exs|exp)
  字符串：We are learning regexp
  ```

  * 以正则为主导，反复测试字符串，这样字符串中同一部分，有可能被反复测试很多次

- DFA 会先看文本，再看正则表达式，是以文本为主导

  ```
  字符串：We are learning regexp
  正则：reg(axs|exs|exp)
  ```

  * DFA 引擎会更快一些，因为整个匹配过程中，字符串只看一遍，不会发生回溯，相同的字符不会被测试两次
  * DFA 引擎执行的时间一般是线性的

### POSIX NFA 与 传统 NFA

* 传统的 NFA 引擎“急于”报告匹配结果，找到第一个匹配上的就返回了，所以可能会导致还有更长的匹配未被发现
* POSIX NFA 在找到可能的最长匹配之前会继续回溯，也就是说它会尽可能找最长的，如果分支一样长，以最左边的为准

## 性能优化



* 做分解
* 分析各个子问题
* 套皮
* 调试
  * 复杂⼀点的正则表达式不能⼀次写对，这是很正常的。与其纠结“这个正则表达式看起来这么复杂，此处到底要用星号 * 还是加号 +，不如先搞清楚，星号（ * ）或加号（ + ）限定的到底是正则表达式中的哪一部分，对应要匹配文本中的哪一部分。这两个问题搞清楚了，整个问题就迎刃而解了
* 克制