# 随记

**算法**

| 题目                     | 解题思路 |
| ------------------------ | -------- |
| 判断合法ip               |          |
| 地图上搜索亮点之间的路径 |          |
|                          |          |

**系统设计**

| 题目       | 解题思路 |
| ---------- | -------- |
| 抢红包系统 |          |
|            |          |
|            |          |



### 泛型

* 作用

  * 根据传入的类型不同而使用对应类型的API
  * 解决不必要的类型转换错误：使用泛型以后在编译时就将类型约束好

* 实现原理

  * 泛型擦除

    * 编译期泛型类型会被擦除（默认Object类型，如果设置了<? extends xx> 则会被擦成 ? 类型）
    * 擦除的原因：兼容

```java
//定义处已经被擦除成Object，无法进行强转，不知道强转成什么public T getB();
   Code:
      0: aload_0
      1: getfield      #23                 // Field b:Ljava/lang/Object;
      4: areturn
//调用处利用checkcast进行强转
L5 {
            aload1
            invokevirtual com/ljj/A getB()Ljava.lang.Object);
            checkcast java/lang/Integer
            invokevirtual java/lang/Integer intValue(()I);
            istore2
    }

```

* 编译期、运行期变量类型是否可知
  * java泛型检查只在编译期有效
  * 只会擦除运行时的泛型类型，编译时类中定义的泛型类型是不会被擦除的
    * 运行时对象本质是方法的调用

* 通配符
  * extends 上限通配符 **可以接收extend后的类型及子类**
  * super 下限通配符 **可以接收super后的类型及父类**

### 排序

* 快速排序
* 堆排序
  * 堆的插入过程
* 并归排序

### 生产者/消费者模型

* 多个读者多个写者会出现饿死吗？

  * 公平锁和非公平锁的性能是不一样的，非公平锁的性能会优于公平锁。为什么呢？因为公平锁在获取锁时，永远是等待时间最长的线程获取到锁，这样当线程T1释放锁以后，如果还想继续再获取锁，它也得去同步队列尾部排队，这样就会频繁的发生线程的上下文切换，当线程越多，对CPU的损耗就会越严重。

  * 非公平锁性能虽然优于公平锁，但是会存在导致线程`饥饿`的情况。在最坏的情况下，可能存在某个线程一直获取不到锁。不过相比性能而言，`饥饿`问题可以暂时忽略，这可能就是ReentrantLock默认创建非公平锁的原因之一了

* 读者远多于写者？

### finalize

* 何时调用
* GC的哪个阶段调用，可能调用多少次

### 优先队列、阻塞队列

### 

### 多态、重写、重载、final修饰



### 线上使用的哪种垃圾回收、聊下垃圾回收的原理



### G1



## IO

### java的线程和系统的线程不是一对一？

是 1:1的

### 进程和线程

**计组**

**C10k问题**

### BIO、NIO