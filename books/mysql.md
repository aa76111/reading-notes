# Mysql

| 问题                                           | 解答                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| 如何避免长事务对业务的影响                     | 开发端：去除无意义的事务，SET MAX_EXECUTION_TIME 命令<br />数据库端：<br />1. 监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill<br />2. Percona 的 pt-kill 这个工具不错，推荐使用<br />3. 在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题<br />4. 如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值） |
| 重建索引                                       | 主键索引的重建或删除，会将整个表重建<br />使用 `alter table T engine=InnoDB` |
| 主库上一个小表做了一个 DDL<br />备库上的现象？ |                                                              |



redo log

binlog



## 索引

### 主键索引

叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）

### 非主键索引

**叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）**

```
select * from T where k = 非主键索引； 会回表查询
```

### 自增主键？

* 自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂
* 非主键索引会存储主键的值，主键越大，无意义的消耗越大
* 适合用业务字段直接做主键：K-V 场景

### 覆盖索引

非主键索引的查询，只查询主键 => 覆盖索引



### 联合索引

考虑联合索引的用处，用来做覆盖索引

**如何安排索引内的字段顺序**：

* 如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的
* 空间：如果必须的话，拿小的字段单独做索引而不是拿大的

**索引下推优化**

```
select * from tuser where name like '张%' and age=10 and ismale=1;
(name, age) 的联合索引，会筛选出来 张% 并且age=10的之后，再回表查询。可以大大减少回表查询次数
```



## 锁

**MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类**

### 全局锁

**典型使用场景：全库逻辑备份**

**弊端**

- 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟

如果所有表使用的是 Innodb，则可重复读级别就可以替代全局锁：`mysqldump 使用参数–single-transaction`

### 表级锁

#### 表锁

` lock tables t1 read, t2 write`：线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表

#### 元数据锁：MDL（metadata lock)

当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行

**如何安全地给小表加字段？**

```
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ... 
```

### 行锁

**InnoDB 支持行锁，这也是 MyISAM 被 InnoDB 替代的重要原因之一**

**两阶段锁协议**

* 在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。
* <font color=orange>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</font>

#### 死锁和死锁检测

* 直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置
* 发起死锁检测，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。`innodb_deadlock_detect `设置为 on(模式就是on)

死锁检测的弊端：

* 每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作

解决死锁检测的弊端

* 关掉死锁检测
* 控制并发度
  * 客户端做并发控制不太现实
  * 数据库服务端做并发控制
  * 修改Mysql：对于相同行的更新，在进入引擎之前排队

